---
title: "RNA Sequencing of the Human Milk Fat Layer Transcriptome Reveals Distinct Gene Expression Profiles at Three Stages of Lactation"
author:
- name: "Nikola Panajotovikj, Ester MuÃ±oz del Campo, Marko Ludaic"
  affiliation: Universitat Pompeu Fabra
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
    toc_float: true
    number_sections: true
    fig_captions: yes
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{IEOprojectAnalysis}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<!--
In this first chunk of code, which will not be shown in the resulting
document (echo=FALSE) sets up global processing options, such as whether
a comment character should appear before code results (set to the null
character string in this case), collapse source and output blocks into
a single code block (collapse=TRUE), align figures to the center
(fig.align="center") or cache the results to speed up vignette building
(cache=FALSE thus disabled in this case). A full description of possible
options can be found at http://yihui.name/knitr/options
--->
```
```{r setup, echo=FALSE, cache=FALSE}
library(knitr) ## kable()
library(kableExtra) ## kable_styling(), save_kable()
library(usethis) ## use_directory(), proj_path()

knitr::opts_chunk$set(
  collapse=TRUE,
  comment="",
  fig.align="center",
  cache=FALSE
)

## this option avoid use_directory() being verbose later on
options(usethis.quiet=TRUE)
```

# Introduction

# Quality assessment

## Data import and cleaning

We start importing the raw table of counts.

```{=html}
<!--
The option 'message=FALSE' avoid dumping R messages such as "Loading required package: methods"
into the output of the report.
-->
```
```{r message=FALSE}
library(SummarizedExperiment)
se <- readRDS(file.path(system.file("extdata", package="IEOproject"), "GSE45669.rds"))
#se <- readRDS("../inst/extdata/GSE45669.rds")

se

```

We have `r nrow(se)` genes by `r ncol(se)` samples. From the first row
and column names shown by the object, we can figure out that genes are
defined by [Entrez](https://www.ncbi.nlm.nih.gov/gene) [@maglott10]
identifiers and samples by Sequence Read Archive Run
([SRR](https://www.ncbi.nlm.nih.gov/books/NBK56913/#search.what_do_the_different_sra_accessi))
identifiers.

The row data in this object contains information about the profiled
genes.

```{r}
head(rowData(se))
```

Among this information, the gene symbol and description are potentially
useful for interpreting results of, for instance, a differential
expression analysis. Let's explore now the column (phenotypic) data.

```{r}
dim(colData(se))
head(colData(se), n=3)
```

We have a total of `r ncol(colData(se))` phenotypic variables. The
second column `geo_accession` contains GEO Sample Accession Number
([GSM](https://www.ncbi.nlm.nih.gov/geo/info/overview.html)) identifers.
GSM identifiers define individual samples, understood in our context as
individual sources of RNA. We can see these are repeated, indicating
that among the `ncol(se)` samples we have technical replicates.

To proceed further exploring this dataset, we are going to use the
[edgeR](https://bioconductor.org/packages/edgeR) package and build a
`DGEList` object, incorporating the gene metadata, which includes the
gene symbol.

```{r, message=FALSE}
library(IEOproject)
library(edgeR)

dge <- DGEList(counts=assays(se)$counts, genes=rowData(se))
dim(dge)
```

Calculate $\log_2$ CPM units of expression and put them as an additional
assay element to ease their manipulation.

```{r}
assays(se)$logCPM <- cpm(dge, log=TRUE)
assays(se)$logCPM[1:5, 1:5]
```

posible groups:

```{r}

# loop over the columns and count unique values
for (col in names(colData(se))) {
  unique_vals <- unique(colData(se)[[col]])
  if (any(length(unique_vals) %in% c(1, 16))) {
    next # skip to the next column
  } else {
    counts <- table(colData(se)[[col]])
    cat(paste0("Column '", col, "' has ", length(unique_vals), " unique values:\n"))
    print(counts)
  }
}

```

NOTE: replace hard-coded values with the r {}

In the output above is from code that goes through all the different
columns and returns the unique values and their count, given that the
whole colum is not the same value or has all different values. Our idea
for this is to see if there are any groups in the data. We can see that
there are:

-   patients that are repeated because their milk was sampled in 2 or 3
    of the 3 stages of lactation reported in the paper (id numbers: 179,
    183, 187)

-   given the different 3 stages, 3 groups of samples appear (this is a
    biologically relevant factor) lactation stage: Colostrum lactation
    stage: Mature lactation stage: Transitional

-   because of the different protocols there are 4 different groups
    (technically relevant) Hard spin, Unwashed ; Hard spin, Washed once
    ; Hard spin, Washed twice ; Soft spin, Unwashed

To facilitate handling these variables we are going to recode them as
follows.

First we replace spaces in column names

```{r}
# simpler names
names(colData(se))[37] <- "id"
names(colData(se))[36] <- "lacStage"
names(colData(se))[35] <- "protocol"

# creating factors
colData(se)$idFac <- factor(colData(se)$id)
# colData(se)$lacStageFac <- factor(colData(se)$lacStage)
colData(se)$lacStageFac <- factor(colData(se)$lacStage,
                                  levels = c("Colostrum", "Transitional", "Mature"),
                                  labels = c(1, 2, 3))

#colData(se)$protocolFac <- factor(colData(se)$protocol)
colData(se)$protocolFac <- factor(colData(se)$protocol,
                                  levels = c("Soft spin, Unwashed", "Hard spin, Unwashed", "Hard spin, Washed once", "Hard spin, Washed twice"),
                                  labels = c(1, 2, 3, 4 ))

```

In Table \@ref(tab:pheno) below, we show this variable jointly with cell
line and treatment to try to gather as much understanding as possible on
the underlying experimental design.

```{r pheno, echo=FALSE, message=FALSE}
tmpdf <- data.frame("Patient"=colData(se)$idFac,
                    "lacStage"=colData(se)$lacStageFac,
                    "protocol"=colData(se)$protocolFac,
                    check.names=FALSE)
ktab <- kable(tmpdf, caption="Phenotypic variables.")
kable_styling(ktab, position="center")
```

## Sequencing depth

Let's examine the sequencing depth in terms of total number of sequence
read counts mapped to the genome per sample. Figure \@ref(fig:libsizes)
below shows the sequencing depth per sample, also known as library
sizes, in increasing order.
```{r}
par(mar=c(7, 5, 2, 2))
ord <- order(dge$sample$lib.size/1e6)
ordmreads <- dge$sample$lib.size[ord]/1e6
names(ordmreads) <- colnames(se)[ord]
bp <- barplot(ordmreads, las=1, ylab="Millions of reads",
              xlab="", col=c("blue", "green", "red")[colData(se)$lacStageFac[ord]], las=2, ylim = c(0, 50))
legend("topleft", c("Colostrum", "Transitional", "Mature"), fill=c("blue", "green", "red"), inset=0.01)
```
From the plot above we don't notice any biases related to the different lactation stages. The only thing that stands out is SRR801705 as having very low sequence depth. In the later part of the analysis we will remove it from the analysis, since it seems to be an error.


```{r}
par(mar=c(7, 5, 2, 2))
ord <- order(dge$sample$lib.size/1e6)
ordmreads <- dge$sample$lib.size[ord]/1e6
names(ordmreads) <- colnames(se)[ord]
bp <- barplot(ordmreads, las=1, ylab="Millions of reads",
              xlab="", col=c("blue", "green", "red", "orange")[colData(se)$protocolFac[ord]], las=2, ylim = c(0, 60))
legend("topleft", c("Soft spin, Unwashed", "Hard spin, Unwashed", "Hard spin, Washed once", "Hard spin, Washed twice"), 
       fill=c("blue", "green", "red", "orange"), inset=0.01)
```
From the plot above we do not see any bias. The "Hard spin, Washed once" group together but there doesn't seem to be an significantly extreme difference in their sequencing depth. We will further analyse this with a clusering approach. 

## Distribution of expression levels among samples

Figure \@ref(fig:distRawExp) below shows the distribution of expression
values per sample in logarithmic CPM units of expression.

```{=html}
<!---
the option echo=FALSE hides the R code. When plotting in general one
does not want to see the code. Options fig.height and fig.width control
height and width of the plot in inches while out.height and out.width
do it in the final output file; see http://yihui.name/knitr/options for
full details.
--->
```
```{r distRawExp, echo=FALSE, fig.height=5, fig.width=5, out.width="600px", fig.cap="Non-parametric density distribution of expression profiles per sample.", message=FALSE}
library(geneplotter)
par(mar=c(4, 5, 1, 1))
lst <- as.list(as.data.frame(assays(se)$logCPM))
multidensity(lst, xlab="log 2 CPM", legend=NULL,
             main="", las=1)
```

There are no substantial differences between the samples in the
distribution of expression values.

```{r}
par(mar=c(7, 5, 2, 2))
boxplot(assays(se)$logCPM, col="gray", ylab=expression(log[2] * "CPM"),
cex.axis=1.2, cex.lab=1.5, las=2)

```
In the previous plots we see that the SRR801705 sample does not behave differently than the rest, but this is due to the fact that we are now considering the counts per million (CPM), and what is wrong about that sample is the sequencing depth, so still we will exclude it from the analysis.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! REMOVE SRR801705

```{r}
# Create logical mask excluding column containing "SRR801705" in the name
mask <- !grepl("SRR801705", colnames(se))

# Subset the data frame using the mask
se_sample_filtered <- se[, mask]

```


## Distribution of expression levels among genes

Let's calculate now the average expression per gene through all the
samples. Figure \@ref(fig:exprdist) shows the distribution of those
values across genes.

```{r exprdist, echo=FALSE, out.width="600px", fig.cap="Distribution of average expression level per gene."}
avgexp <- rowMeans(assays(se)$logCPM)
hist(avgexp, xlab="log2 CPM", main="", las=1)
```

As expected, we have two modes, one for genes that are lowly expressed
in nearly all samples and another for genes with some detectable levels
of expression across a number of samples.

## Filtering of lowly-expressed genes


We filter lowly-expressed genes using the function `filterByExpr()`,
grouping by sample-group to define the minimum number of samples in
which a gene should be expressed.

```{r}
mask <- filterByExpr(dge, group=se$samplegroup)
se.filt <- se[mask, ]
dim(se.filt)
dge.filt <- dge[mask, ]
dim(dge.filt)
```

We are left with `r nrow(se.filt)` genes.

## Normalization

We calculate now the normalization factors on the filtered expression
data set.

```{r}
dge.filt <- calcNormFactors(dge.filt)
```

Replace the raw log2 CPM units in the corresponding assay element of the
`SummarizedExperiment` object, by the normalized ones.

```{r}
assays(se.filt)$logCPM <- cpm(dge.filt, log=TRUE,
                              normalized.lib.sizes=TRUE)
```

## MA-plots

We examine now the MA-plots of the normalized expression profiles in
Figure \@ref(fig:maPlots).

```{=html}
<!---
Here we make a MA-plot for each sample. The options 'fig.height'
and 'fig.width' control the relative image size in *inches*. The
final image size results from 'height'x'dpi' and 'width'x'dpi',
where 'dpi' is the image resolution in "dots per inch" (by default
dpi=72). To scale the image to a desired size use 'out.width' and
'out.height'. More information at http://yihui.name/knitr/options
--->
```
```{r maPlots, fig.height=18, fig.width=10, dpi=100, echo=FALSE, fig.cap="MA-plots of filtered and normalized expression values."}
par(mfrow=c(5, 4), mar=c(4, 5, 3, 1))
for (i in 1:ncol(se.filt)) {
  A <- rowMeans(assays(se.filt)$logCPM)
  M <- assays(se.filt)$logCPM[, i] - A
  smoothScatter(A, M, main=colnames(se.filt)[i], las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

A number of samples display some expression-level dependent bias. For
cases in which this occurs at the low-end of the expression level, one
solution could be to have a more stringent filter on minimum expression
(using a grouping with more samples per group, for instance). We should
keep an eye on samples with these biases in case they also display other
unexpected features, because then we might consider removing them.

## Experimental design and batch identification

Here try to understand the underlying experimental design. Let's start
examining the distribution of samples across the combination of cell
line and treatment.

```{r}
table(se.filt$cell_line, se.filt$treatment)
```

We can see that not all combinations of cell line and treatment have
been sequenced. For this reason, we can anticipate that it won't be
possible to identify expression changes associated with all levels of
these two factors. We will have to make comparisons within each cell
line, between those treatments that have been sequenced.

Now, let's look at the combination of sample preparation protocol and
cell line.

```{r}
table(se.filt$extract_protocol_ch1, se$cell_line)
```

We can see that there is a perfect correlation between sample
preparation protocol and cell line because the two cell lines were
processed with different sample preparation protocols. This means that
differences between NHBE and A549 samples are not going to be only due
to biological differences but also technical.

We examine now how samples group together by hierarchical clustering and
multidimensional scaling, annotating sample group and treatment. We
calculate again log CPM values with a high prior count(3) to moderate
extreme fold-changes produced by low counts. The resulting dendrogram is
shown in Figure \@ref(fig:sampleClustering).

```{r sampleClustering, fig.height=5, fig.width=8, dpi=100, echo=FALSE, fig.cap="Figure S6: Hierarchical clustering of the samples. Labels correspond to treatment and sample identifer, while colors indicate sample group."}
logCPM <- cpm(dge.filt, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(se.filt$samplegroup)
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.filt)
outcome <- paste(se.filt$treatment, colnames(se), sep="\n")
names(outcome) <- colnames(se.filt)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples",
     cex=0.7)
legend("topright", levels(se.filt$samplegroup),
       fill=seq_len(nlevels(se.filt$samplegroup)))
```

As expected, NHBE cell line samples cluster separately from A549 samples
and cell line seems to drive the largest portion of the variablity in
the whole dataset. Next to this observation, all samples cluster by
sample group, except one of the IAV-infected cells. Looking up its
identifier, it does not correspond to the sample of lowest sequencing
depth and therefore, there's probably other reason than depth to cluster
away from its group. In Figure \@ref(fig:mdsPlot) we show the
corresponding MDS plot.

```{r mdsPlot, fig.height=5, fig.width=8, dpi=100, echo=FALSE, fig.cap="Figure S7: Multidimensional scaling plot of the samples. Labels correspond to treatment and colors indicate sample group."}
outcome <- se.filt$treatment
names(outcome) <- colnames(se.filt)
plotMDS(dge.filt, labels=outcome, col=batch)
legend("bottomleft", levels(se.filt$samplegroup),
       fill=seq_len(nlevels(se.filt$samplegroup)), inset=0.05)
```

The MDS plot shows even more clear differences between A549 and NHBE
samples and suggests clearly that samples group by the type of
infection. As described by @blancomelo20, mock-treated samples were
cultured to match the conditions of the corresponding infected samples.
For this reason, in this dataset it only makes sense to compare infected
with mock samples within their corresponding cultured group.

# Differential expression

We perform a simple assessment of the extent of expression changes and
their associated p-values using the F-test implemented in the
R/Bioconductor package [sva](http://bioconductor.org/packages/sva). We
compare mock with SARS-Cov-2 infected samples in the NHBE cell line. We
first subset the data as follows:

```{r}
se.filt.COV2NHBE <- se.filt[, se.filt$samplegroup == "COV2NHBE"]
se.filt.COV2NHBE$treatment <- droplevels(se.filt.COV2NHBE$treatment)
```

In the second step above, we dropped the unused levels from the
treatment factor variable. This is important to avoid using factor
levels that do not exist in this subset of the data. We build now the
corresponding full and null model matrices.

```{r}
mod <- model.matrix(~ se.filt.COV2NHBE$treatment,
                    colData(se.filt.COV2NHBE))
mod0 <- model.matrix(~ 1, colData(se.filt.COV2NHBE))
```

Finally, we conduct the F-test implemented in the package `sva` and
examine the amount of differential expression between SARS-Cov-2
infected and mock cells.

```{r, message=FALSE}
library(sva)

pv <- f.pvalue(assays(se.filt.COV2NHBE)$logCPM, mod, mod0)
sum(p.adjust(pv, method="fdr") < 0.05)
sum(p.adjust(pv, method="fdr") < 0.1)
```

We obtain `r sum(p.adjust(pv, method="fdr") < 0.05)` differentially
expressed (DE) genes at FDR \< 5% and
`r sum(p.adjust(pv, method="fdr") < 0.1)` at FDR \< 10%. In Figure
\@ref(fig:pdistCOV2NHBE) below we can see the distribution of the
resulting p-values.

```{r pdistCOV2NHBE, echo=FALSE, out.width="600px", fig.cap="Distribution of raw p-values for an F-test on every gene between SARS-Cov-2 infected and mock samples in NHBE cell lines."}
hist(pv, main="", las=1)
```

We build a table with the subset of
`r sum(p.adjust(pv, method="fdr") < 0.1)` DE genes with FDR \< 10% and
show the top-10 genes with lowest p-value in Table
\@ref(tab:DEgenesSARScov2NHBE) below.

```{r, message=FALSE}
mask <- p.adjust(pv, method="fdr") < 0.1
DEgenesEGs <- names(pv)[mask]
DEgenesSyms <- mcols(se.filt)[DEgenesEGs, "symbol"]
DEgenesPvalue <- pv[mask]
DEgenesDesc <- mcols(se.filt)[DEgenesEGs, "description"]
DEgenesDesc <- sub(" \\[.+\\]", "", DEgenesDesc)
DEgenesTab <- data.frame(EntrezID=DEgenesEGs,
                         Symbol=DEgenesSyms,
                         Description=DEgenesDesc,
                         "P value"=DEgenesPvalue,
                         stringsAsFactors=FALSE, check.names=FALSE)
DEgenesTab <- DEgenesTab[order(DEgenesTab[["P value"]]), ] ## order by p-value
rownames(DEgenesTab) <- 1:nrow(DEgenesTab)
```

```{=html}
<!--
The following code chunk is hidden because its lines are not that relevant
to the analysis of the data. Their purpose is to dump the table of DE genes
into an HTML table and a CSV file to facilitate the examination of long lists
of DE genes while avoiding to produce a lengthy vignette by showing only the
top-10 DE genes.
--->
```
```{r, echo=FALSE}
## generate full table in a CSV file and store it in the 'doc' directory
## twice, once in 'doc' to enable quickly look up during vignette editing
## and building with 'devtools::build_vignettes()' and a second time in
## 'inst/doc' to make these files available at install.
use_directory(file.path("doc"))
use_directory(file.path("inst", "doc"))
fnameCSV <- "DEgenesSARScov2NHBE.csv"
fpathCSV <- proj_path(file.path("doc", fnameCSV))
write.csv(DEgenesTab, fpathCSV, row.names=FALSE)
fpathCSV <- proj_path(file.path("inst", "doc", fnameCSV))
write.csv(DEgenesTab, fpathCSV, row.names=FALSE)

## generate full table in HTML and store it into the 'doc' directory
## twice, just as we did with the CSV file. note that because the
## table caption is not translated from Markdown, but directly copied
## into HTML, we need to avoid using the '<' symbol, as in FDR < 10%,
## and put its HTML code instead (&lt;)
ktab <- kable(DEgenesTab, "html", escape=FALSE, row.names=TRUE,
              caption=sprintf("Differentially expressed genes. Differentially expressed genes between SARS-Cov-2 infected and mock NHBE cells with FDR &lt; 10%% (CSV <a href=\"%s\" download>file</a>).",
                              fnameCSV))
ktab <- kable_styling(ktab,
                      bootstrap_options=c("stripped", "hover", "responsive"),
                      fixed_thead=TRUE)
fnameHTML <- "DEgenesSARScov2NHBE.html"
fpathHTML <- proj_path(file.path("doc", fnameHTML))
save_kable(ktab, file=fpathHTML, self_contained=TRUE)
fpathHTML <- proj_path(file.path("inst", "doc", fnameHTML))
save_kable(ktab, file=fpathHTML, self_contained=TRUE)
```

```{=html}
<!--
The following code chunk is also hidden because its purpose is to produce
a short HTML table of the top-10 DE genes. The reason show here only the
top-10 genes is to producing a long vignette. The full HTML table and the
corresponding CSV file are linked through the caption of this short HTML
table.

note that because the table caption is not translated from Markdown, but
directly copied into HTML, we need to avoid using the '<' symbol, as in
FDR < 10%, and put its HTML code instead (&lt;)
--->
```
```{r DEgenesSARScov2NHBE, echo=FALSE}
ktab <- kable(DEgenesTab[1:10, ], "html", escape=FALSE, row.names=TRUE, 
              caption=sprintf("Differentially expressed genes. Top-10 differentially expressed genes with lowest p-value between SARS-Cov-2 infected and mock NHBE cells with FDR &lt; 10%%. To see the full list of DE genes, follow this <a href=\"%s\" target=\"_blank\">link</a> or download this CSV <a href=\"%s\" download>file</a>.",
                              fnameHTML, fnameCSV))
kable_styling(ktab, position="center")
```

# Functional analysis

Here we will do the functional analysis.

# Discussion

Here we discuss the findings.

# Conclusions

Here we summarize our conclusions.

# Session information

```{r}
sessionInfo()
```

# References
